/**
 * generated by Xtext 2.25.0
 */
package org.tetrabox.example.scoping;

import com.google.common.base.Objects;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.tetrabox.example.minitl.BinaryExpression;
import org.tetrabox.example.minitl.FieldAccessValue;
import org.tetrabox.example.minitl.MinitlPackage;
import org.tetrabox.example.minitl.ObjectTemplate;
import org.tetrabox.example.minitl.ObjectTemplateValue;
import org.tetrabox.example.minitl.StringValue;
import org.tetrabox.example.minitl.Value;
import org.tetrabox.example.minitl.impl.BindingImpl;
import org.tetrabox.example.minitl.impl.FieldAccessValueImpl;
import org.tetrabox.example.minitl.impl.ObjectTemplateImpl;

/**
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class MinitlScopeProvider extends AbstractMinitlScopeProvider {
  private EClass _inferType(final BinaryExpression value) {
    return null;
  }
  
  private EClass _inferType(final StringValue value) {
    return null;
  }
  
  private EClass _inferType(final ObjectTemplateValue value) {
    return value.getObjecttemplate().getType();
  }
  
  private EClass _inferType(final FieldAccessValue value) {
    final EClass leftType = this.inferType(value.getObject());
    boolean _notEquals = (!Objects.equal(leftType, null));
    if (_notEquals) {
      boolean _contains = leftType.getEAllStructuralFeatures().contains(value.getFeature());
      if (_contains) {
        final EClassifier resultType = value.getFeature().getEType();
        if ((resultType instanceof EClass)) {
          return ((EClass) resultType);
        }
      }
    }
    return null;
  }
  
  private IScope scopeObjectTemplateFeatures(final ObjectTemplate o) {
    final Set<EStructuralFeature> result = IterableExtensions.<EStructuralFeature>toSet(o.getType().getEAllStructuralFeatures());
    return Scopes.scopeFor(result);
  }
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    boolean _matched = false;
    if (Objects.equal(reference, MinitlPackage.Literals.BINDING__FEATURE)) {
      _matched=true;
      boolean _matched_1 = false;
      if (context instanceof ObjectTemplateImpl) {
        _matched_1=true;
        return this.scopeObjectTemplateFeatures(((ObjectTemplate)context));
      }
      if (!_matched_1) {
        if (context instanceof BindingImpl) {
          _matched_1=true;
          EObject _eContainer = ((BindingImpl)context).eContainer();
          return this.scopeObjectTemplateFeatures(((ObjectTemplate) _eContainer));
        }
      }
    }
    if (!_matched) {
      if (Objects.equal(reference, MinitlPackage.Literals.FIELD_ACCESS_VALUE__FEATURE)) {
        _matched=true;
        boolean _matched_2 = false;
        if (context instanceof FieldAccessValueImpl) {
          _matched_2=true;
          final EClass inferredType = this.inferType(((FieldAccessValueImpl)context).getObject());
          boolean _notEquals = (!Objects.equal(inferredType, null));
          if (_notEquals) {
            return Scopes.scopeFor(inferredType.getEAllStructuralFeatures());
          } else {
            return Scopes.scopeFor(Collections.<EObject>unmodifiableSet(CollectionLiterals.<EObject>newHashSet()));
          }
        }
      }
    }
    return super.getScope(context, reference);
  }
  
  private EClass inferType(final Value value) {
    if (value instanceof BinaryExpression) {
      return _inferType((BinaryExpression)value);
    } else if (value instanceof FieldAccessValue) {
      return _inferType((FieldAccessValue)value);
    } else if (value instanceof ObjectTemplateValue) {
      return _inferType((ObjectTemplateValue)value);
    } else if (value instanceof StringValue) {
      return _inferType((StringValue)value);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(value).toString());
    }
  }
}
